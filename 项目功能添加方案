这是一个针对现有 `nano-backend` 项目的后端功能扩展方案。根据你的需求，我们需要构建一个层级化的“项目审阅”系统。

由于现有的架构比较简洁（主要由 `models`, `handlers`, `database` 组成），我将按照这种模式来设计扩展。

### 1. 数据库模型设计 (`internal/models/models.go`)

我们需要添加三张新表来对应 **项目 (ReviewProject)**、**单集 (ReviewEpisode)** 和 **分镜 (ReviewStoryboard)**。

```go
package models

// ... (保留原有代码)

// --- 影视项目审阅系统模型 ---

type ReviewProject struct {
	ID          string `gorm:"primaryKey" json:"id"`
	UserID      string `gorm:"index" json:"userId"` // 创建者
	Name        string `json:"name"`
	CoverFileID string `json:"coverFileId"` // 关联 File 表 ID
	EpisodeCount int   `gorm:"-" json:"episodeCount"` // 动态计算或缓存
	CreatedAt   int64  `json:"createdAt"`
	UpdatedAt   int64  `json:"updatedAt"`
}

type ReviewEpisode struct {
	ID              string `gorm:"primaryKey" json:"id"`
	ProjectID       string `gorm:"index" json:"projectId"`
	UserID          string `gorm:"index" json:"userId"`
	Name            string `json:"name"`
	CoverFileID     string `json:"coverFileId"`
	StoryboardCount int    `gorm:"-" json:"storyboardCount"`
	CreatedAt       int64  `json:"createdAt"`
	UpdatedAt       int64  `json:"updatedAt"`
}

type ReviewStoryboard struct {
	ID          string  `gorm:"primaryKey" json:"id"`
	EpisodeID   string  `gorm:"index" json:"episodeId"`
	UserID      string  `gorm:"index" json:"userId"` // 创建者
	ImageFileID string  `json:"imageFileId"`         // 必须有图
	Status      string  `json:"status"`              // pending(未审阅), approved(通过), rejected(未通过)
	Feedback    string  `json:"feedback"`            // 修改建议
	SortOrder   int     `json:"sortOrder"`           // 用于拖拽排序
	CreatedAt   int64   `json:"createdAt"`
	UpdatedAt   int64   `json:"updatedAt"`
}

// 响应结构体 (用于前端展示)
type ReviewStoryboardResponse struct {
	ReviewStoryboard
	ImageURL string `json:"imageUrl"`
}

```

---

### 2. 数据库操作层 (`internal/database/review.go`)

需要在 `database` 包中添加对应的增删改查逻辑。

* **CreateReviewProject**: 创建项目。
* **ListReviewProjects**: 获取某用户的项目列表。
* **CreateReviewEpisode**: 在指定项目下创建单集。
* **ListReviewEpisodes**: 获取指定项目的单集列表。
* **CreateReviewStoryboard**: 创建分镜，注意初始化 `Status="pending"` 和 `SortOrder`（可以是当前最大Order+1）。
* **UpdateStoryboardStatus**: 更新状态和修改建议。
* **UpdateStoryboardOrder**: 批量更新排序。

---

### 3. 业务逻辑与控制层 (`internal/handlers/review_handlers.go`)

建议新建一个 `review_handlers.go` 文件来处理这些逻辑，保持代码整洁。

#### 3.1 辅助函数

我们需要复用文件上传逻辑。现有的 `saveBufferToFile` 在 `handlers.go` 中是私有的。建议将其改为 `SaveBufferToFile` (首字母大写) 或在 `handlers` 包内复用。

#### 3.2 核心 Handler 实现

```go
package handlers

import (
	"nano-backend/internal/database"
	"nano-backend/internal/models"
	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
	"strings"
)

// ========== 影视项目 (Projects) ==========

// 创建影视项目
func CreateReviewProject(c *fiber.Ctx) error {
	user := middleware.GetCurrentUser(c)
	name := c.FormValue("name")
	
	if name == "" {
		return c.Status(400).JSON(fiber.Map{"error": "项目名称不能为空"})
	}

	// 处理封面上传 (非必要)
	var coverFileID string
	fileHeader, err := c.FormFile("cover")
	if err == nil {
		// 复用现有的文件保存逻辑
		file, _ := fileHeader.Open()
		buf, _ := io.ReadAll(file)
		savedFile, err := saveBufferToFile(user.ID, "project-cover", fileHeader.Header.Get("Content-Type"), fileHeader.Filename, buf, true)
		if err == nil {
			coverFileID = savedFile.ID
		}
	}

	project := &models.ReviewProject{
		ID:          uuid.New().String(),
		UserID:      user.ID,
		Name:        name,
		CoverFileID: coverFileID,
		CreatedAt:   models.Now(),
	}

	if err := database.CreateReviewProject(project); err != nil {
		return c.Status(500).JSON(fiber.Map{"error": "创建失败"})
	}

	return c.JSON(project)
}

// 获取项目列表
func ListReviewProjects(c *fiber.Ctx) error {
	user := middleware.GetCurrentUser(c)
	projects, err := database.ListReviewProjects(user.ID)
	// ... 处理错误 ...
	return c.JSON(projects)
}

// ========== 影视单集 (Episodes) ==========

// 创建单集
func CreateReviewEpisode(c *fiber.Ctx) error {
	user := middleware.GetCurrentUser(c)
	projectID := c.Params("projectId")
	name := c.FormValue("name")

	// ... 校验 ProjectID 是否属于该用户 ...

	// 处理封面上传 (同上)
	var coverFileID string
	fileHeader, err := c.FormFile("cover")
	if err == nil {
		// ... 保存文件逻辑 ...
	}

	episode := &models.ReviewEpisode{
		ID:          uuid.New().String(),
		ProjectID:   projectID,
		UserID:      user.ID,
		Name:        name,
		CoverFileID: coverFileID,
		CreatedAt:   models.Now(),
	}

	// database.CreateReviewEpisode(episode)
	return c.JSON(episode)
}

// ========== 分镜 (Storyboards) ==========

// 创建分镜
func CreateReviewStoryboard(c *fiber.Ctx) error {
	user := middleware.GetCurrentUser(c)
	episodeID := c.Params("episodeId")
	name := c.FormValue("name") // 虽然模型没写name，但前端需求提到了“分镜名字”，建议模型加上或存入Name字段

	// 处理分镜图片 (必要)
	fileHeader, err := c.FormFile("image")
	if err != nil {
		return c.Status(400).JSON(fiber.Map{"error": "必须上传分镜图片"})
	}
	
	// 读取并保存图片
	file, _ := fileHeader.Open()
	buf, _ := io.ReadAll(file)
	savedFile, err := saveBufferToFile(user.ID, "storyboard-image", fileHeader.Header.Get("Content-Type"), fileHeader.Filename, buf, true)
	if err != nil {
		return c.Status(500).JSON(fiber.Map{"error": "图片保存失败"})
	}

	// 获取当前最大排序值以便追加到末尾
	maxOrder := database.GetMaxStoryboardOrder(episodeID)

	storyboard := &models.ReviewStoryboard{
		ID:          uuid.New().String(),
		EpisodeID:   episodeID,
		UserID:      user.ID,
		ImageFileID: savedFile.ID,
		Status:      "pending", // 默认为灰色/未审阅
		SortOrder:   maxOrder + 1,
		CreatedAt:   models.Now(),
	}

	// database.CreateReviewStoryboard(storyboard)
	return c.JSON(storyboard)
}

// 审阅/修改分镜状态
func ReviewStoryboard(c *fiber.Ctx) error {
	storyboardID := c.Params("id")
	var body struct {
		Status   string `json:"status"`   // "approved" 或 "rejected"
		Feedback string `json:"feedback"` // 当 rejected 时必填
	}
	
	if err := c.BodyParser(&body); err != nil {
		return c.Status(400).JSON(fiber.Map{"error": "格式错误"})
	}

	if body.Status == "rejected" && body.Feedback == "" {
		return c.Status(400).JSON(fiber.Map{"error": "未通过时必须填写修改建议"})
	}

	// database.UpdateStoryboardStatus(storyboardID, body.Status, body.Feedback)
	return c.JSON(fiber.Map{"ok": true})
}

// 分镜排序 (拖拽后调用)
func ReorderStoryboards(c *fiber.Ctx) error {
	// 接收一个有序的ID列表
	var body struct {
		StoryboardIDs []string `json:"storyboardIds"`
	}
	// ... 遍历ID列表，更新数据库中的 SortOrder 字段 ...
	return c.JSON(fiber.Map{"ok": true})
}

```

---

### 4. 路由配置 (`main.go`)

在 `setupRoutes` 函数中添加新的 API 组：

```go
// 影视项目审阅相关路由
review := app.Group("/api/review", authMiddleware)

// 项目
review.Get("/projects", handlers.ListReviewProjects)
review.Post("/projects", handlers.CreateReviewProject)
review.Get("/projects/:id", handlers.GetReviewProject) // 进入项目详情

// 单集
review.Get("/projects/:projectId/episodes", handlers.ListReviewEpisodes)
review.Post("/projects/:projectId/episodes", handlers.CreateReviewEpisode)

// 分镜
review.Get("/episodes/:episodeId/storyboards", handlers.ListReviewStoryboards)
review.Post("/episodes/:episodeId/storyboards", handlers.CreateReviewStoryboard)
review.Put("/storyboards/reorder", handlers.ReorderStoryboards) // 排序
review.Patch("/storyboards/:id/status", handlers.ReviewStoryboard) // 审阅 (通过/不通过)

```

### 5. 功能流程总结

1. **创建项目**: 前端 POST `/api/review/projects` (FormData: `name`, `cover`) -> 后端存库，返回 Project 对象。
2. **创建单集**: 前端 POST `/api/review/projects/{id}/episodes` -> 后端关联 ProjectID 存库。
3. **创建分镜**: 前端 POST `/api/review/episodes/{id}/storyboards` (FormData: `image`, `name`) -> 后端存图，生成记录，`Status` 设为 `pending` (灰色)。
4. **审阅**:
* 点击“通过” -> 前端 PATCH `/api/review/storyboards/{id}/status` (`status: "approved"`) -> 变绿。
* 点击“不通过” -> 填写建议 -> 前端 PATCH (`status: "rejected"`, `feedback: "..."`) -> 变红。


5. **查看**: 前端 GET `/api/review/episodes/{id}/storyboards` -> 获取列表，每个对象包含 `fileId` (用于生成图片URL)、`status`、`feedback`，前端据此渲染颜色和文本。